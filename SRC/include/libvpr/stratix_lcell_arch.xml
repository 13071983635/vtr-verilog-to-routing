  <architecture>
  
  <!-- Stratix Models -->
  <models>
    
    <!-- from stratix_lcell.v -->
    <model name="stratix_lcell">
      <input_ports> 
      <port name="dataa"/> <!-- data a -->
      <port name="datab"/> <!-- data b -->
      <port name="datac"/> <!-- data c-->
      <port name="datad"/> <!-- data d -->
      <port name="aclr"/> <!-- asynchronous clear -->
      <port name="sclr"/> <!-- synchronous clear-->
      <port name="aload"/> <!-- asynchronous load -->
      <port name="sload"/> <!-- synchronous load-->
      <port name="ena"/> <!-- clock enable-->
      <port name="cin"/> <!-- carry in -->
      <port name="inverta"/> <!-- invert for dataa -->
      <port name="regcascin"/> <!-- cascade in -->
      <port name="clk" is_clock="1"/> <!-- clock -->
      <port name="devclrn"/>
      <port name="devpor"/>
      </input_ports>
      <output_ports>
      <port name="combout"/> <!-- combinational output -->
      <port name="regout"/> <!-- registered output -->
      <port name="cout"/> <!-- carry out -->
      </output_ports>
    </model>
 
  </models>
  <!-- Stratix config ends -->
 
  <!-- Physical descriptions begin (area optimized for N8-K6-L4 -->
  <layout auto="1.0"/>
		<device>
			<sizing R_minW_nmos="4220.930176" R_minW_pmos="11207.599609" ipin_mux_trans_size="1.299940"/>
			<timing C_ipin_cblock="0.000000e+00" T_ipin_cblock="8.582000e-11"/>
			<area grid_logic_tile_area="0.0"/>
			<chan_width_distr>
				<io width="1.000000"/>
				<x distr="uniform" peak="1.000000"/>
				<y distr="uniform" peak="1.000000"/>
			</chan_width_distr>
			<switch_block type="wilton" fs="3"/>
		</device>
		<switchlist>
			<switch type="mux" name="0" R="0.000000" Cin="0.000000e+00" Cout="0.000000e+00" Tdel="8.972000e-11" mux_trans_size="2.183570" buf_size="32.753502"/>
		</switchlist>
		<segmentlist>
			<segment freq="1.000000" length="4" type="unidir" Rmetal="0.000000" Cmetal="0.000000e+00">
			<mux name="0"/>
			<sb type="pattern">1 1 1 1 1</sb>
			<cb type="pattern">1 1 1 1</cb>
			</segment>
		</segmentlist>
		<complexblocklist>

      <!-- Capacity is a unique property of I/Os, it is the maximum number of I/Os that can be placed at the same (X,Y) location on the FPGA -->
      <pb_type name="io" capacity="7">
        <input name="outpad" num_pins="1" equivalent="false"/>
        <output name="inpad" num_pins="1"/>
        <clock name="clock" num_pins="1"/>

        <!-- IOs can operate as either inputs or outputs -->
        <mode name="inpad">
          <pb_type name="inpad" blif_model=".input" num_pb="1">
            <output name="inpad" num_pins="1"/>
          </pb_type>
          <interconnect>
            <direct name="inpad" input="inpad.inpad" output="io.inpad"/>
          </interconnect>
      
        </mode>
        <mode name="outpad">
          <pb_type name="outpad" blif_model=".output" num_pb="1">
            <input name="outpad" num_pins="1"/>
          </pb_type>
          <interconnect>
            <direct name="outpad" input="io.outpad" output="outpad.outpad"/>
          </interconnect>
        </mode>

        <fc_in type="frac">0.15</fc_in>
        <fc_out type="frac">0.125</fc_out>

        <!-- IOs go on the periphery of the FPGA, for consistency, 
          make it physically equivalent on all sides so that only one definition of I/Os is needed.
          If I do not make a physically equivalent definition, then I need to define 4 different I/Os, one for each side of the FPGA
        -->
        <pinlocations pattern="custom">
          <loc side="left">io.outpad io.inpad io.clock</loc>
          <loc side="top">io.outpad io.inpad io.clock</loc>
          <loc side="right">io.outpad io.inpad io.clock</loc>
          <loc side="bottom">io.outpad io.inpad io.clock</loc>
        </pinlocations>

        <gridlocations>
          <loc type="perimeter" priority="10"/>
        </gridlocations>

      </pb_type>
      
      <pb_type name="clb">
        
          <input name="I" num_pins="14" equivalent="true"/>
          <output name="O" num_pins="3"/>
          <clock name="clk" num_pins="1"/>
          
          <mode name="lcell">
          <pb_type name="lcell" blif_model=".subckt stratix_lcell" num_pb="1">
			 	<input name="dataa" num_pins="1"/> <!-- data a -->
      			<input name="datab" num_pins="1"/> <!-- data b -->
      			<input name="datac" num_pins="1"/> <!-- data c-->
      			<input name="datad" num_pins="1"/> <!-- data d -->
      			<input name="aclr" num_pins="1"/> <!-- asynchronous clear -->
      			<input name="sclr" num_pins="1"/> <!-- synchronous clear-->
      			<input name="aload" num_pins="1"/> <!-- asynchronous load -->
      			<input name="sload" num_pins="1"/> <!-- synchronous load-->
      			<input name="ena" num_pins="1"/> <!-- clock enable-->
      			<input name="cin" num_pins="1"/> <!-- carry in -->
      			<input name="inverta" num_pins="1"/> <!-- invert for dataa -->
      			<input name="regcascin" num_pins="1"/> <!-- cascade in -->
      			<input name="devclrn" num_pins="1"/>
      			<input name="devpor" num_pins="1"/>
                <output name="combout" num_pins="1"/> <!-- combinational output -->
      			<output name="regout" num_pins="1"/> <!-- registered output -->
      			<output name="cout" num_pins="1"/> <!-- carry out -->
             	<clock name="clk" num_pins="1"/>
          </pb_type>
			
          <interconnect>
          	<complete name="complete1" input="clb.I" output="lcell.dataa"/>
          	<complete name="complete2" input="clb.I" output="lcell.datab"/>
          	<complete name="complete3" input="clb.I" output="lcell.datac"/>
          	<complete name="complete4" input="clb.I" output="lcell.datad"/>
          	<complete name="complete5" input="clb.I" output="lcell.aclr"/>
          	<complete name="complete6" input="clb.I" output="lcell.sclr"/>
          	<complete name="complete7" input="clb.I" output="lcell.aload"/>
          	<complete name="complete8" input="clb.I" output="lcell.sload"/>
          	<complete name="complete9" input="clb.I" output="lcell.ena"/>
          	<complete name="complete10" input="clb.I" output="lcell.cin"/>
          	<complete name="complete11" input="clb.I" output="lcell.inverta"/>
          	<complete name="complete12" input="clb.I" output="lcell.regcascin"/>
          	<complete name="complete13" input="clb.I" output="lcell.devpor"/>
          	<complete name="complete14" input="clb.I" output="lcell.devclrn"/>
          	
          	<complete name="complete15" input="lcell.combout" output="clb.O"/>
          	<complete name="complete16" input="lcell.regout" output="clb.O"/>
          	<complete name="complete17" input="lcell.cout" output="clb.O"/>
		   	<direct   name="direct1" input="clb.clk" output="lcell.clk"/>  
            
          </interconnect>
        </mode>
        
        <mode name="n2_lut5">
              <pb_type name="lut5" blif_model=".names" num_pb="2" class="lut">
                <input name="in" num_pins="5" port_class="lut_in"/>
                <output name="out" num_pins="1" port_class="lut_out"/>
              </pb_type>
              <interconnect>
                <complete name="l_complete1" input="clb.I" output="lut5[0:0].in[4:0]"/>
                <complete name="l_complete2" input="lut5[0:0].out" output="clb.O"/>
                <complete name="l_complete3" input="clb.I" output="lut5[1:1].in[4:0]"/>
                <complete name="l_complete4" input="lut5[1:1].out" output="clb.O"/>
              </interconnect>
        </mode>
        
        <fc_in type="frac">0.150000</fc_in>
        <fc_out type="frac">0.125000</fc_out>
        <pinlocations pattern="spread"/>
        <gridlocations>
          <loc type="fill" priority="1"/>
        </gridlocations>
      </pb_type>

    </complexblocklist>
  </architecture>
