<!-- 
    Stratix Architecture
    Instantiates an arbitrary arrangment of Stratix blocks including:
      stratix_lcell
      stratix_mac_mult
      stratix_mac_out
      stratix_ram_block
    
    NOTE: Doesn't support parameters or configuration.
-->
<!-- C:->UserProgramFiles->altera->11.0->quartus->eda->fv_lib->verilog -->

<architecture>

  <!-- Stratix Models -->
  <models>

    <!-- from stratix_lcell.v -->
    <model name="stratix_lcell">
      <input_ports>
        <port name="dataa"/>  <!-- data a -->
        <port name="datab"/>  <!-- data b -->
        <port name="datac"/>  <!-- data c-->
        <port name="datad"/>  <!-- data d -->
        <port name="aclr"/>   <!-- asynchronous clear -->
        <port name="sclr"/>   <!-- synchronous clear-->
        <port name="aload"/>  <!-- asynchronous load -->
        <port name="sload"/>  <!-- synchronous load-->
        <port name="ena"/>    <!-- clock enable-->
        <port name="cin"/>    <!-- carry in -->
        <port name="inverta"/>  <!-- invert for dataa -->
        <port name="regcascin"/>  <!-- cascade in -->
        <port name="clk" is_clock="1"/> <!-- clock -->
        <port name="devclrn"/>
        <port name="devpor"/>
      </input_ports>
      <output_ports>
        <port name="combout"/>  <!-- combinational output -->
        <port name="regout"/>   <!-- registered output -->
        <port name="cout"/>     <!-- carry out -->
      </output_ports>
    </model>

    <!-- from stratix_mac_mult.v -->
    <model name="stratix_mac_mult">
      <input_ports>
        <port name="dataa"/>
        <port name="datab"/>
        <port name="aclr"/>
        <port name="signa"/>
        <port name="signb"/>
        <port name="ena"/>
        <port name="clk"/>
        <port name="devclrn"/>
        <port name="devpor"/>
      </input_ports>
      <output_ports>
        <port name="scanouta"/>
        <port name="scanoutb"/>
        <port name="dataout"/>
      </output_ports>
    </model>

    <!-- from stratix_mac_out.v -->
    <model name="stratix_mac_out">
      <input_ports>
        <port name="dataa"/>
        <port name="datab"/>
        <port name="datac"/>
        <port name="datad"/>
        <port name="zeroacc"/>
        <port name="addnsub0"/>
        <port name="addnsub1"/>
        <port name="signa"/>
        <port name="signb"/>
        <port name="ena"/>
        <port name="clk"/>
        <port name="aclr"/>
        <port name="devclrn"/>
        <port name="devpor"/>
      </input_ports>
      <output_ports>
        <port name="accoverflow"/>
        <port name="dataout"/>
      </output_ports>
    </model>

    <!-- from stratix_ram_block.v -->
    <model name="stratix_ram_block">
      <input_ports>
        <port name="portawe"/>
        <port name="portabyteenamasks"/>
        <port name="portbbyteenamasks"/>
        <port name="portbrewe"/>
        <port name="clr0"/>
        <port name="clr1"/>
        <port name="clk0"/>
        <port name="clk1"/>
        <port name="ena0"/>
        <port name="ena1"/>
        <port name="portadatain"/>
        <port name="portbdatain"/>
        <port name="portaaddr"/>
        <port name="portbaddr"/>
        <port name="devclrn"/>
        <port name="devpor"/>
      </input_ports>
      <output_ports>
        <port name="portadataout"/>
        <port name="portbdataout"/>
      </output_ports>
    </model>

  </models>
  <!-- ODIN II specific config ends -->
 
  <!-- Physical descriptions begin (area optimized for N8-K6-L4 -->
  <layout auto="1.0"/>
		<device>
			<sizing R_minW_nmos="4220.930176" R_minW_pmos="11207.599609" ipin_mux_trans_size="1.299940"/>
			<timing C_ipin_cblock="0.000000e+00" T_ipin_cblock="8.582000e-11"/>
			<area grid_logic_tile_area="0.0"/>
			<chan_width_distr>
				<io width="1.000000"/>
				<x distr="uniform" peak="1.000000"/>
				<y distr="uniform" peak="1.000000"/>
			</chan_width_distr>
			<switch_block type="wilton" fs="3"/>
		</device>
		<switchlist>
			<switch type="mux" name="0" R="0.000000" Cin="0.000000e+00" Cout="0.000000e+00" Tdel="8.972000e-11" mux_trans_size="2.183570" buf_size="32.753502"/>
		</switchlist>
		<segmentlist>
			<segment freq="1.000000" length="4" type="unidir" Rmetal="0.000000" Cmetal="0.000000e+00">
			<mux name="0"/>
			<sb type="pattern">1 1 1 1 1</sb>
			<cb type="pattern">1 1 1 1</cb>
			</segment>
		</segmentlist>
				<complexblocklist>

      <!-- Capacity is a unique property of I/Os, it is the maximum number of I/Os that can be placed at the same (X,Y) location on the FPGA -->
      <pb_type name="io" capacity="7">
        <input name="outpad" num_pins="1" equivalent="false"/>
        <output name="inpad" num_pins="1"/>
        <clock name="clock" num_pins="1"/>

        <!-- IOs can operate as either inputs or outputs -->
        <mode name="inpad">
          <pb_type name="inpad" blif_model=".input" num_pb="1">
            <output name="inpad" num_pins="1"/>
          </pb_type>
          <interconnect>
            <direct name="inpad" input="inpad.inpad" output="io.inpad"/>
          </interconnect>
      
        </mode>
        <mode name="outpad">
          <pb_type name="outpad" blif_model=".output" num_pb="1">
            <input name="outpad" num_pins="1"/>
          </pb_type>
          <interconnect>
            <direct name="outpad" input="io.outpad" output="outpad.outpad"/>
          </interconnect>
        </mode>

        <fc_in type="frac">0.15</fc_in>
        <fc_out type="frac">0.125</fc_out>

        <!-- IOs go on the periphery of the FPGA, for consistency, 
          make it physically equivalent on all sides so that only one definition of I/Os is needed.
          If I do not make a physically equivalent definition, then I need to define 4 different I/Os, one for each side of the FPGA
        -->
        <pinlocations pattern="custom">
          <loc side="left">io.outpad io.inpad io.clock</loc>
          <loc side="top">io.outpad io.inpad io.clock</loc>
          <loc side="right">io.outpad io.inpad io.clock</loc>
          <loc side="bottom">io.outpad io.inpad io.clock</loc>
        </pinlocations>

        <gridlocations>
          <loc type="perimeter" priority="10"/>
        </gridlocations>

      </pb_type>
      
      <pb_type name="clb">
        
          <input name="I" num_pins="14" equivalent="true"/>
          <output name="O" num_pins="3"/>
          <clock name="clk" num_pins="1"/>
          
          <mode name="lcell">
          <pb_type name="lcell" blif_model=".subckt stratix_lcell" num_pb="1">
			 	      <input name="dataa" num_pins="1"/> <!-- data a -->
      			  <input name="datab" num_pins="1"/> <!-- data b -->
      			  <input name="datac" num_pins="1"/> <!-- data c-->
      			  <input name="datad" num_pins="1"/> <!-- data d -->
      			  <input name="aclr" num_pins="1"/> <!-- asynchronous clear -->
      			  <input name="sclr" num_pins="1"/> <!-- synchronous clear-->
      			  <input name="aload" num_pins="1"/> <!-- asynchronous load -->
      			  <input name="sload" num_pins="1"/> <!-- synchronous load-->
      			  <input name="ena" num_pins="1"/> <!-- clock enable-->
      			  <input name="cin" num_pins="1"/> <!-- carry in -->
      			  <input name="inverta" num_pins="1"/> <!-- invert for dataa -->
      			  <input name="regcascin" num_pins="1"/> <!-- cascade in -->
      			  <input name="devclrn" num_pins="1"/>
      			  <input name="devpor" num_pins="1"/>
              <output name="combout" num_pins="1"/> <!-- combinational output -->
      			  <output name="regout" num_pins="1"/> <!-- registered output -->
      			  <output name="cout" num_pins="1"/> <!-- carry out -->
             	<clock name="clk" num_pins="1"/>
          </pb_type>
			
          <interconnect>
          	<complete name="complete1" input="clb.I" output="lcell.dataa"/>
          	<complete name="complete2" input="clb.I" output="lcell.datab"/>
          	<complete name="complete3" input="clb.I" output="lcell.datac"/>
          	<complete name="complete4" input="clb.I" output="lcell.datad"/>
          	<complete name="complete5" input="clb.I" output="lcell.aclr"/>
          	<complete name="complete6" input="clb.I" output="lcell.sclr"/>
          	<complete name="complete7" input="clb.I" output="lcell.aload"/>
          	<complete name="complete8" input="clb.I" output="lcell.sload"/>
          	<complete name="complete9" input="clb.I" output="lcell.ena"/>
          	<complete name="complete10" input="clb.I" output="lcell.cin"/>
          	<complete name="complete11" input="clb.I" output="lcell.inverta"/>
          	<complete name="complete12" input="clb.I" output="lcell.regcascin"/>
          	<complete name="complete13" input="clb.I" output="lcell.devpor"/>
          	<complete name="complete14" input="clb.I" output="lcell.devclrn"/>
          	
          	<complete name="complete15" input="lcell.combout" output="clb.O"/>
          	<complete name="complete16" input="lcell.regout" output="clb.O"/>
          	<complete name="complete17" input="lcell.cout" output="clb.O"/>
		   	    <direct   name="direct1" input="clb.clk" output="lcell.clk"/>  
            
          </interconnect>
        </mode>
        <mode name="n2_lut5">
              <pb_type name="lut5" blif_model=".names" num_pb="2" class="lut">
                <input name="in" num_pins="5" port_class="lut_in"/>
                <output name="out" num_pins="1" port_class="lut_out"/>
              </pb_type>
              <interconnect>
                <complete name="l_complete1" input="clb.I" output="lut5[0:0].in[4:0]"/>
                <complete name="l_complete2" input="lut5[0:0].out" output="clb.O"/>
                <complete name="l_complete3" input="clb.I" output="lut5[1:1].in[4:0]"/>
                <complete name="l_complete4" input="lut5[1:1].out" output="clb.O"/>
              </interconnect>
        </mode>
        
        <fc_in type="frac">0.150000</fc_in>
        <fc_out type="frac">0.125000</fc_out>
        <pinlocations pattern="spread"/>
        <gridlocations>
          <loc type="fill" priority="1"/>
        </gridlocations>
      </pb_type>
          
          
      <pb_type name="mac_multiply">
          <input name="data" num_pins="36"/>
          <input name="signal" num_pins="12"/>
          <input name ="CLK" num_pins="4"/>
          <output name="out" num_pins="72"/>
          
          <mode name="mac_mult">
            <pb_type name="mac_mult" blif_model=".subckt stratix_mac_mult" num_pb="1">
              <input name="dataa" num_pins="18"/>
              <input name="datab" num_pins="18"/>
              
              <input name="signa" num_pins="1"/>
              <input name="signb" num_pins="1"/>
              <input name="aclr" num_pins="4"/>
              <input name="ena" num_pins="4"/>
              <input name="devclrn" num_pins="1"/>
              <input name="devpor" num_pins="1"/>
              <input name="clk" num_pins="4"/>
              
              <output name="scanouta" num_pins="18"/>
              <output name="scanoutb" num_pins="18"/>
              <output name="dataout" num_pins="36"/>

            </pb_type>
            
            <interconnect>
              <complete name="data_c1" input="mac_multiply.data" output="mac_mult.dataa"/>
              <complete name="data_c2" input="mac_multiply.data" output="mac_mult.datab"/>
              
              <complete name="signal_c1" input="mac_multiply.signal" output="mac_mult.signa"/>
              <complete name="signal_c2" input="mac_multiply.signal" output="mac_mult.signb"/>
              <complete name="signal_c3" input="mac_multiply.signal" output="mac_mult.aclr"/>
              <complete name="signal_c4" input="mac_multiply.signal" output="mac_mult.ena"/>
              <complete name="signal_c5" input="mac_multiply.signal" output="mac_mult.devclrn"/>
              <complete name="signal_c6" input="mac_multiply.signal" output="mac_mult.devpor"/>

              <complete name="out_c1" input="mac_mult.scanouta" output="mac_multiply.out"/>
              <complete name="out_c2" input="mac_mult.scanoutb" output="mac_multiply.out"/>
              <complete name="out_c3" input="mac_mult.dataout" output="mac_multiply.out"/>

              <complete name="clock_c1" input="mac_multiply.CLK" output="mac_mult.clk"/>
            </interconnect>
          </mode>

        <fc_in type="frac">0.15</fc_in>
        <fc_out type="frac">0.125</fc_out>
        <pinlocations pattern="spread"/>

        <gridlocations>
          <loc type="col" start="2" repeat="5" priority="2"/>
        </gridlocations>
      </pb_type>

      <pb_type name="mac_output">
         <input name="data" num_pins="144"/>
         <input name="signal" num_pins="15"/>
         <input name ="CLK" num_pins="4"/>
         <output name="out" num_pins="73"/>
        
         <mode name="mac_out">
           
           <pb_type name="mac_out" blif_model=".subckt stratix_mac_out" num_pb="1">
               <input name="dataa" num_pins="36"/>
               <input name="datab" num_pins="36"/>
               <input name="datac" num_pins="36"/>
               <input name="datad" num_pins="36"/>
             
               <input name="zeroacc" num_pins="1"/>
               <input name="addnsub0" num_pins="1"/>
               <input name="addnsub1" num_pins="1"/>
               <input name="signa" num_pins="1"/>
               <input name="signb" num_pins="1"/>
               <input name="ena" num_pins="4"/>
               <input name="aclr" num_pins="4"/>
               <input name="devclrn" num_pins="1"/>
               <input name="devpor" num_pins="1"/>

               <input name="clk" num_pins="4"/>

               <output name="accoverflow" num_pins="1"/>
               <output name="dataout" num_pins="72"/>

           </pb_type>
            
           <interconnect>
             <complete name="data_c1" input="mac_output.data" output="mac_out.dataa"/>
             <complete name="data_c2" input="mac_output.data" output="mac_out.datab"/>
             <complete name="data_c3" input="mac_output.data" output="mac_out.datac"/>
             <complete name="data_c4" input="mac_output.data" output="mac_out.datad"/>
             
             <complete name="signal_c1" input="mac_output.signal" output="mac_out.zeroacc"/>
             <complete name="signal_c2" input="mac_output.signal" output="mac_out.addnsub0"/>
             <complete name="signal_c3" input="mac_output.signal" output="mac_out.addnsub1"/>
             <complete name="signal_c4" input="mac_output.signal" output="mac_out.signa"/>
             <complete name="signal_c5" input="mac_output.signal" output="mac_out.signb"/>
             <complete name="signal_c6" input="mac_output.signal" output="mac_out.ena"/>
             <complete name="signal_c7" input="mac_output.signal" output="mac_out.aclr"/>
             <complete name="signal_c8" input="mac_output.signal" output="mac_out.devclrn"/>
             <complete name="signal_c9" input="mac_output.signal" output="mac_out.devpor"/>
             
             <complete name="out_c1" input="mac_out.accoverflow" output="mac_output.out"/>
             <complete name="out_c3" input="mac_out.dataout" output="mac_output.out"/>
             
             <complete name="clock_c1" input="mac_output.CLK" output="mac_out.clk"/>
           </interconnect>
         </mode>
        
         <fc_in type="frac">0.15</fc_in>
         <fc_out type="frac">0.125</fc_out>
         <pinlocations pattern="spread"/>
        
         <gridlocations>
           <loc type="col" start="3" repeat="5" priority="2"/>
         </gridlocations>
       </pb_type>
      
      <pb_type name="memory">
         <input name="data" num_pins="40"/>
         <input name="dataa_addr" num_pins="16"/>
         <input name="datab_addr" num_pins="16"/>
         <input name="signal" num_pins="24"/>
         <input name ="CLK" num_pins="40"/>
         <output name="out" num_pins="40"/>
        
         <mode name="ram_block">
           
           <pb_type name="ram_block" blif_model=".subckt stratix_ram_block" num_pb="20">
               <input name="portadatain" num_pins="1"/>
               <input name="portbdatain" num_pins="1"/>
               <input name="portaaddr" num_pins="16"/>
               <input name="portbaddr" num_pins="16"/>

               <input name="portawe" num_pins="1"/> 
               <input name="portabyteenamasks" num_pins="8"/>
               <input name="portbbyteenamasks" num_pins="8"/>
               <input name="portbrewe" num_pins="1"/>
               <input name="clr0" num_pins="1"/>
               <input name="clr1" num_pins="1"/>
               <input name="ena0" num_pins="1"/>
               <input name="ena1" num_pins="1"/>
               <input name="devclrn" num_pins="1"/>
               <input name="devpor" num_pins="1"/>

               <input name="clk0" num_pins="1"/>
               <input name="clk1" num_pins="1"/>

               <output name="portadataout" num_pins="1"/>
               <output name="portbdataout" num_pins="1"/>
           </pb_type>
            
           <interconnect>
             <complete name="addr_c1" input="memory.dataa_addr" output="ram_block[19:0].portaaddr"/>
             <complete name="addr_c2" input="memory.datab_addr" output="ram_block[19:0].portbaddr"/>
             
             <complete name="data_c1" input="memory.data" output="ram_block[19:0].portadatain"/>
             <complete name="data_c2" input="memory.data" output="ram_block[19:0].portbdatain"/>
             
             <complete name="signal_c1" input="memory.signal" output="ram_block[19:0].portawe"/>
             <complete name="signal_c2" input="memory.signal" output="ram_block[19:0].portabyteenamasks"/>
             <complete name="signal_c3" input="memory.signal" output="ram_block[19:0].portbbyteenamasks"/>
             <complete name="signal_c4" input="memory.signal" output="ram_block[19:0].portbrewe"/>
             <complete name="signal_c5" input="memory.signal" output="ram_block[19:0].clr0"/>
             <complete name="signal_c6" input="memory.signal" output="ram_block[19:0].clr1"/>
             <complete name="signal_c7" input="memory.signal" output="ram_block[19:0].ena0"/>
             <complete name="signal_c8" input="memory.signal" output="ram_block[19:0].devclrn"/>
             <complete name="signal_c9" input="memory.signal" output="ram_block[19:0].devpor"/>
             
             <complete name="out_c1" input="ram_block[19:0].portadataout" output="memory.out"/>
             <complete name="out_c3" input="ram_block[19:0].portbdataout" output="memory.out"/>

             <complete name="clock_c1" input="memory.CLK" output="ram_block[19:0].clk0"/>
             <complete name="clock_c2" input="memory.CLK" output="ram_block[19:0].clk1"/>
           </interconnect>
         </mode>
        
         <fc_in type="frac">0.15</fc_in>
         <fc_out type="frac">0.125</fc_out>
         <pinlocations pattern="spread"/>
        
         <gridlocations>
           <loc type="col" start="4" repeat="5" priority="2"/>
         </gridlocations>
       </pb_type>
          
    </complexblocklist>
  </architecture>
